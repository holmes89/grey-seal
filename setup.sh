#!/bin/bash
# setup.sh - Complete setup for Document RAG System

set -e

echo "ðŸš€ Setting up Document RAG System with Ollama integration..."

# Create directories
mkdir -p sample-docs data logs

# Create sample documents
echo "ðŸ“„ Creating sample documents..."

cat > sample-docs/golang.txt << 'EOF'
Go is an open-source programming language developed by Google. It was designed by Robert Griesemer, Rob Pike, and Ken Thompson. Go is statically typed and compiled, making it fast and efficient. It features garbage collection, memory safety, and CSP-style concurrency with goroutines and channels.

Go is particularly well-suited for building microservices, web applications, and cloud-native applications. Its simple syntax and powerful standard library make it a popular choice for backend development. The language emphasizes simplicity, readability, and efficiency.

Key features of Go include:
- Fast compilation
- Built-in concurrency support
- Strong standard library
- Cross-platform support
- Excellent tooling ecosystem
EOF

cat > sample-docs/kubernetes.txt << 'EOF'
Kubernetes is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. Originally developed by Google, it is now maintained by the Cloud Native Computing Foundation.

Kubernetes provides a framework for running distributed systems resiliently. It takes care of scaling requirements, failover, deployment patterns, and more. Key concepts in Kubernetes include:

- Pods: The smallest deployable units
- Services: Network abstractions for accessing pods
- Deployments: Declarative updates for pods and ReplicaSets
- ConfigMaps and Secrets: Configuration management
- Ingress: HTTP and HTTPS routing
- Persistent Volumes: Storage abstractions

Kubernetes has become the de facto standard for container orchestration in cloud-native environments. It works well with microservices architectures and provides excellent scalability and reliability features.
EOF

cat > sample-docs/vectors.txt << 'EOF'
Vector databases are specialized databases designed to store, index, and search high-dimensional vector data. They are essential for modern AI applications, particularly those involving similarity search, recommendation systems, and retrieval-augmented generation (RAG).

Unlike traditional databases that store structured data in rows and columns, vector databases store numerical vectors that represent data points in high-dimensional space. These vectors are typically generated by machine learning models that convert text, images, or other data types into numerical representations called embeddings.

Key features of vector databases include:
- Similarity search using cosine similarity, Euclidean distance, or dot product
- Indexing algorithms like HNSW (Hierarchical Navigable Small World) or IVF (Inverted File)
- Horizontal scalability for large datasets
- Real-time search capabilities
- Integration with machine learning pipelines

Popular vector databases include Pinecone, Weaviate, Qdrant, and ChromaDB. Many traditional databases are also adding vector capabilities, such as PostgreSQL with the pgvector extension.
EOF

cat > sample-docs/microservices.txt << 'EOF'
Microservices architecture is a design approach where applications are built as a collection of loosely coupled, independently deployable services. Each service is responsible for a specific business capability and communicates with other services through well-defined APIs.

Benefits of microservices include:
- Independent deployment and scaling
- Technology diversity - different services can use different tech stacks
- Improved fault isolation
- Better team organization around business domains
- Easier maintenance and updates

Challenges include:
- Increased complexity in service communication
- Data consistency across services
- Monitoring and observability
- Service discovery and load balancing
- Testing across service boundaries

Microservices work well with containerization technologies like Docker and orchestration platforms like Kubernetes. They are often implemented using patterns like API gateways, circuit breakers, and event-driven architectures.
EOF

# Create enhanced docker-compose with Ollama
cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  # Main RAG application
  rag-server:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - ./data:/app/data
      - ./sample-docs:/app/sample-docs:ro
      - ./logs:/app/logs
    environment:
      - GIN_MODE=release
      - OLLAMA_URL=http://ollama:11434
      - EMBEDDING_MODEL=nomic-embed-text
      - LLM_MODEL=llama3.2
    depends_on:
      - ollama
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Ollama for embeddings and LLM
  ollama:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:11434/api/tags"]
      interval: 30s
      timeout: 10s
      retries: 5
    # For GPU support (uncomment if you have NVIDIA GPU)
    # deploy:
    #   resources:
    #     reservations:
    #       devices:
    #         - driver: nvidia
    #           count: 1
    #           capabilities: [gpu]

  # Optional: Web UI for testing
  swagger-ui:
    image: swaggerapi/swagger-ui
    ports:
      - "8081:8080"